name: Build & Check Services (No Tests)

on:
  push:
    branches: ["**"]
  pull_request:

jobs:
  build-check:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install, Build, and Quick-boot Each Service (node only)
        run: |
          echo "üîç Checking all Node.js services (non-docker quick boot)"
          for dir in services/*; do
            if [ -f "$dir/package.json" ]; then
              echo "üì¶ Installing dependencies in $dir"
              cd "$dir"
              npm ci || npm install

              echo "üöÄ Building (if script exists)"
              npm run build --if-present

              echo "üß™ Start briefly to ensure it doesn't instantly crash"
              if npm run dev --if-present & then
                pid=$!
                sleep 5
                if ps -p $pid > /dev/null; then
                  echo "‚úÖ $dir runs (node quick-boot ok)"; kill $pid
                else
                  echo "‚ùå $dir crashed during node quick-boot"; exit 1
                fi
              elif npm start & then
                pid=$!
                sleep 5
                if ps -p $pid > /dev/null; then
                  echo "‚úÖ $dir runs (node quick-boot ok)"; kill $pid
                else
                  echo "‚ùå $dir crashed during node quick-boot"; exit 1
                fi
              else
                echo "‚ö†Ô∏è No start/dev script found for $dir (skipping quick-boot)"
              fi

              cd ../../
            fi
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Detect changed services
        id: changed
        run: |
          BASE_SHA="${{ github.event.before || github.event.pull_request.base.sha || 'HEAD~1' }}"
          HEAD_SHA="${{ github.sha }}"
          services=$(bash scripts/list_changed_services.sh "$BASE_SHA" "$HEAD_SHA" || true)
          echo "services<<EOF" >> $GITHUB_OUTPUT
          echo "${services}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Changed services:"; echo "${services}"

      - name: Set image tag
        id: tag
        run: echo "value=$(bash scripts/image_tag.sh)" >> $GITHUB_OUTPUT

      - name: Build Docker Images (no secrets)
        if: steps.changed.outputs.services != ''
        run: |
          tag='${{ steps.tag.outputs.value }}'
          while read svc; do
            [ -z "$svc" ] && continue
            image="local/${svc}:${tag}"
            echo "üîß Building $image from services/$svc"
            docker build -t "$image" "services/$svc"
          done <<< "${{ steps.changed.outputs.services }}"

      - name: Run containers & fail if any crash (collect all failures)
        if: steps.changed.outputs.services != ''
        run: |
          STARTUP_SECS=15
          tag='${{ steps.tag.outputs.value }}'
          FAIL=0
          SUMMARY=""

          while read svc; do
            [ -z "$svc" ] && continue
            cname="${svc}-check"
            image="local/${svc}:${tag}"

            echo "üß™ Starting $image as $cname"
            # Start detached; do NOT exit the step on start failure ‚Äî record and continue
            if ! docker run -d --name "$cname" "$image" > /dev/null 2>&1; then
              echo "‚ùå $svc failed to start (docker run error)"
              SUMMARY="${SUMMARY}\n‚ùå ${svc}: failed to start (docker run error)"
              FAIL=1
              # Try to print logs if any
              docker logs "$cname" 2>/dev/null | tail -n 50 || true
              # Ensure cleanup
              docker rm -f "$cname" >/dev/null 2>&1 || true
              continue
            fi

            echo "‚è≥ Waiting ${STARTUP_SECS}s for $svc to initialize‚Ä¶"
            sleep "${STARTUP_SECS}"

            # Gather status
            status=$(docker inspect "$cname" --format='{{.State.Status}}' 2>/dev/null || echo "unknown")
            exit_code=$(docker inspect "$cname" --format='{{.State.ExitCode}}' 2>/dev/null || echo "999")
            health=$(docker inspect "$cname" --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' 2>/dev/null || echo "unknown")

            echo "üîç $svc -> status=$status exit_code=$exit_code health=$health"
            echo "----- Last 50 log lines for $svc -----"
            docker logs "$cname" 2>/dev/null | tail -n 50 || true
            echo "--------------------------------------"

            # Decide failure:
            # 1) Exited with non-zero exit code
            # 2) Healthcheck present and unhealthy
            # 3) Exited even with zero (treat as fail for long-running services)
            if [ "$status" = "exited" ] && [ "$exit_code" -ne 0 ]; then
              echo "‚ùå ${svc} crashed (exit code $exit_code)"
              SUMMARY="${SUMMARY}\n‚ùå ${svc}: crashed (exit $exit_code)"
              FAIL=1
            elif [ "$health" = "unhealthy" ]; then
              echo "‚ùå ${svc} is unhealthy"
              SUMMARY="${SUMMARY}\n‚ùå ${svc}: unhealthy (HEALTHCHECK failed)"
              FAIL=1
            elif [ "$status" = "exited" ]; then
              echo "‚ùå ${svc} exited during startup (unexpected)"
              SUMMARY="${SUMMARY}\n‚ùå ${svc}: exited during startup"
              FAIL=1
            else
              echo "‚úÖ ${svc} is running"
              SUMMARY="${SUMMARY}\n‚úÖ ${svc}: running"
            fi

            # Cleanup the check container
            docker rm -f "$cname" >/dev/null 2>&1 || true
          done <<< "${{ steps.changed.outputs.services }}"

          echo -e "üìã Summary:${SUMMARY}"
          if [ "$FAIL" -ne 0 ]; then
            echo "‚ùå One or more services failed at runtime."
            exit 1
          fi
          echo "‚úÖ All services passed the runtime check."

      - name: List built images
        run: docker images
